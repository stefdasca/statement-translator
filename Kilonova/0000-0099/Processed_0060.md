# Task

We have a rectangle of dimensions `N × M`. It is helpful to think of our rectangle as a matrix, so we will consider that it has `N` rows and `M` columns. We will segment and number our rectangle according to a certain code `C`. Segmentation means drawing a horizontal or vertical line at a certain position `k`, which will split our rectangle into two smaller rectangles:
* of dimensions `k × M` (the top one) and `(N − k) × M` (the bottom one) – in the case of a (H)orizontal line, an operation encoded by `Hk`
* of dimensions `N × k` (the left one) and `N × (M − k)` (the right one) – in the case of a (V)ertical line, an operation encoded by `Vk`

The numbering of the rectangle is done with natural numbers `1, 2, 3, ...,` in this order.

The code `C` for segmenting and numbering a rectangle is defined recursively. If $C_1$ and $C_2$ are segmentation and numbering codes, then:
* `∗` – in each cell of the rectangle, the current numbering value will be written. After that, this value is incremented to be used by a subsequent operation of type `*`;
* $HkC_1C_2$ – a **horizontal** line is drawn at position `k`, the top rectangle is segmented and numbered according to code $C_1$, then the bottom rectangle continues to be segmented and numbered according to code $C_2$;
* $VkC_1C_2$ – a **vertical** line is drawn at position `k`, the left rectangle is segmented and numbered according to code $C_1$, then the right rectangle continues to be segmented and numbered according to code $C_2$.

For example, the rectangle with dimensions `8×6` (`8` rows, `6` columns) segmented and numbered according to the code `C = H5H3V2∗∗V3∗∗V5V2∗∗∗`, will look like in Figure 1.

~[dreptunghi.png]

A segmentation and numbering code `C` is **valid** for a rectangle of dimensions `N × M` if and only if for each operation of type $HkC_1C_2$ and type $VkC_1C_2$ within `C`, the position `k` where the horizontal or vertical line is drawn is **strictly** inside the current rectangle (i.e., on **both** sides of the drawn line there is at least one row and one column left that will be subsequently numbered according to the recursive definition of the code `C`).

A valid segmentation and numbering code `C` for a rectangle of dimensions `N × M` generates multiple **subdivisions** (smaller rectangles) delimited by the horizontal and vertical lines drawn within `C`. For example, for the rectangle in Figure `1`, the code `C` from the example above generates **`7`** subdivisions.

The code `C` is not uniquely determined. For the segmented and numbered rectangle in Figure `1`, there are `4` equivalent codes, which we write in **lexicographical** order hereafter:

1. `H3V2∗∗H2V3∗∗V2∗V3∗∗`
2. `H3V2∗∗H2V3∗∗V5V2∗∗∗`
3. `H5H3V2∗∗V3∗∗V2∗V3∗∗`
4. `H5H3V2∗∗V3∗∗V5V2∗∗∗`

To determine the lexicographical order of two encodings, each **compact** information that is part of the sequence will be considered a **separate** entity: that is, the symbols `H, V, ∗` of character type, and the numbers `k` of integer type, regardless of the number of digits they are composed of.

At the character level, the lexicographical order is `H < V < ∗`. Numbers will be compared based on their value, for example `1 < 7 < 12`. We will consider that a character is lexicographically smaller than an integer number.

For example, the following two equivalent codes are written in lexicographical order:
1. `V7∗V6∗∗`
2. `V13V7∗∗∗`

and correspond to the rectangle below:

~[dreptunghi2.png]

# Task

Given a segmentation and numbering code, determine:
1. the number of subdivisions it generates;
2. the dimensions of a rectangle with the smallest area for which this code is valid;
3. the number of distinct encodings **modulo `1 000 000 007`**, equivalent to the given code (this number will include the initial code);
4. the first code in lexicographical order equivalent to the given one.

# Input data

From standard input, the following will be read:
* the first line contains the value of `P`;
* the next line contains a string of characters representing the segmentation and numbering code `C`.

# Output data

* **If the read value for `P` is `1`**, then the standard output will print the number of subdivisions generated by the code `C`;
* **If the read value for `P` is `2`**, then the standard output will print two numbers `N` and `M` separated by a space, the dimensions of a rectangle with the smallest area for which the read code `C` is valid. In case there are multiple, any of them is acceptable;
* **If the read value for `P` is `3`**, then the standard output will print the number of distinct encodings **modulo `1 000 000 007`** equivalent to the read code (the read code `C` itself will be included in this number).
* **If the read value for `P` is `4`**, then the standard output will print the first code in lexicographical order equivalent to the given one.

# Constraints and clarifications
* `0 <` length of the code `C` (number of characters) `< 350`
* For tests worth `14` points, we have `P = 1`.
* For tests worth `21` points, we have `P = 2`.
* For tests worth `29` points, we have `P = 3`.
* For tests worth `36` points, we have `P = 4`.

# Example

`stdin`

```
1
H3V2**H2V3**V2*V3**
```

`stdout`

```
7
```

`stdin`

```
2
H3V2**H2V3**V2*V3**
```

`stdout`

```
6 6
```

`stdin`

```
3
H3V2**H2V3**V2*V3**
```

`stdout`

```
4
```

`stdin`

```
4
H3V2**H2V3**V2*V3**
```

`stdout`

```
H3V2**H2V3**V2*V3**
```

Explanations
---

As a result of the segmentation, `7` rectangles are obtained.
The smallest rectangle for which the code is valid has `6` rows and `6` columns.
The number of codes equivalent to the read one is `4` (see the example from the statement).
The first code in lexicographical order equivalent to the read one is `H3V2∗∗H2V3∗∗V2∗V3∗∗`.